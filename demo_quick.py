"""
Quick Demo - Unified System with Real Database
===============================================

Shows bidirectional data flow using REAL schema adapter.
"""

import sys
from pathlib import Path

# Add to path BEFORE importing
unified_path = Path(__file__).parent / "unified-intelligence"
sys.path.insert(0, str(unified_path))

import psycopg2
from datetime import datetime
from database_bridge import DatabaseBridge
from shared_models import Transaction, CustomerProfile, FraudAlert, RiskLevel
from schema_adapter import SchemaAdapter

print("="*70)
print(" UNIFIED SYSTEM DEMO - Schema Adapter in Action")
print("="*70)

# Database config
db_config = {
    'host': 'localhost',
    'port': '5432',
    'dbname': 'frauddb',
    'user': 'postgres',
    'password': 'postgres'
}

# Initialize bridge
bridge = DatabaseBridge(db_config)

print("\n[1] Creating test data in Java-style schema...")
conn = psycopg2.connect(**db_config)
cursor = conn.cursor()

# Insert customer (Java-style)
cursor.execute("""
    INSERT INTO customers (customer_id, first_name, last_name, email, phone, created_at)
    VALUES ('DEMO_001', 'John', 'Doe', 'john@example.com', '555-1234', %s)
    ON CONFLICT (customer_id) DO NOTHING
""", (datetime.now(),))

# Insert transaction (Java-style)
cursor.execute("""
    INSERT INTO transactions (
        transaction_id, customer_id, amount, merchant_name, 
        merchant_category, transaction_date, currency, transaction_type,
        location_city, location_country, device_fingerprint,
        source_system, normalized_at, created_at
    ) VALUES (
        'TX_DEMO_001', 'DEMO_001', 15000.00, 'Luxury Electron',
        'Electronics', %s, 'USD', 'PURCHASE',
        'Las Vegas', 'US', 'dev_abc123',
        'JAVA_BATCH', %s, %s
    )
    ON CONFLICT (transaction_id) DO NOTHING
""", (datetime.now(), datetime.now(), datetime.now()))

# Insert customer profile (Java-style)
cursor.execute("""
    INSERT INTO customer_profiles (
        customer_id, business_type, expected_monthly_volume,
        expected_max_amount, kyc_document_source, confidence_score,
        created_at, updated_at
    ) VALUES (
        'DEMO_001', 'Individual', 5000.00, 2000.00,
        'ID_Verified', 0.85, %s, %s
    )
    ON CONFLICT (customer_id) DO UPDATE SET
        updated_at = EXCLUDED.updated_at
""", (datetime.now(), datetime.now()))

conn.commit()
cursor.close()
print("   Test data created in database")

print("\n[2] Reading transaction through SchemaAdapter...")
txn = bridge.get_transaction('TX_DEMO_001')
if txn:
    print(f"   Transaction ID: {txn.transaction_id}")
    print(f"   Customer: {txn.customer_id}")
    print(f"   Amount: ${txn.amount:.2f}")
    print(f"   Merchant: {txn.merchant_name}")
    print(f"   Location: {txn.location}")  # Adapted from location_city/country
    print(f"   Device: {txn.device_id}")    # Adapted from device_fingerprint

print("\n[3] Reading customer profile through SchemaAdapter...")
profile = bridge.get_customer_profile('DEMO_001')
if profile:
    print(f"   Customer ID: {profile.customer_id}")
    print(f"   Account Type: {profile.account_type}")  # Adapted from business_type
    print(f"   Avg Transaction: ${profile.avg_transaction_amount:.2f}")  # Adapted from expected_monthly_volume
    print(f"   Max Amount: ${profile.max_transaction_amount:.2f}")
    print(f"   Risk Score: {profile.unified_risk_score:.2f}")  # Adapted from confidence_score
    print(f"   KYC Summary: {profile.kyc_summary}")

print("\n[4] Python enriches profile (unified model)...")
# Update profile with Python-side enrichments
profile.behavior_cluster = "high_value_occasional"
profile.anomaly_score = 0.72
profile.spending_pattern = "Occasional large purchases"
profile.occupation = "Engineer"

# Save back through adapter (converts to Java schema)
bridge.upsert_customer_profile(profile)
print("   Enriched profile saved")

print("\n[5] Verify Java can read enriched data...")
conn = psycopg2.connect(**db_config)
cursor = conn.cursor()
cursor.execute("""
    SELECT business_type, expected_monthly_volume, confidence_score, updated_at
    FROM customer_profiles
    WHERE customer_id = 'DEMO_001'
""")
row = cursor.fetchone()
cursor.close()
if row:
    print(f"   Java reads: business_type={row[0]}, volume={row[1]}, score={row[2]}")
    print(f"   Updated at: {row[3]}")

print("\n[6] Creating fraud alert (unified format)...")
alert = FraudAlert(
    alert_id='12345',  # Will be converted to int or generated by DB
    transaction_id='TX_DEMO_001',
    customer_id='DEMO_001',
    rule_based_score=0.85,
    ml_model_score=0.78,
    llm_risk_score=0.92,
    final_risk_score=0.85,
    risk_level=RiskLevel.HIGH,
    detection_method='UNIFIED_INTELLIGENCE',
    rules_triggered=['HIGH_AMOUNT', 'UNUSUAL_LOCATION', 'NEW_DEVICE'],
    ml_features={'velocity_30d': 3, 'avg_amount_ratio': 7.5},
    llm_reasoning='Transaction shows high risk: Large amount in unusual location with new device',
    supporting_documents=[],
    status='PENDING',
    assigned_to=None,
    resolution_notes=None,
    created_at=datetime.now(),
    updated_at=datetime.now()
)

# Save through adapter (converts to Java schema)
bridge.save_fraud_alert(alert)
print("   Alert saved")

print("\n[7] Verify Java can read unified alert...")
cursor = conn.cursor()
cursor.execute("""
    SELECT alert_type, fraud_score, risk_level, rules_triggered, description
    FROM fraud_alerts
    WHERE transaction_id = 'TX_DEMO_001'
    ORDER BY created_at DESC
    LIMIT 1
""")
row = cursor.fetchone()
cursor.close()
conn.close()
if row:
    print(f"   Java reads: type={row[0]}, score={row[1]}, level={row[2]}")
    print(f"   Rules: {row[3]}")
    print(f"   Description: {row[4][:60]}...")
else:
    print("   No alert found")

print("\n" + "="*70)
print(" KEY ACHIEVEMENTS")
print("="*70)
print(" 1. Single shared data models (Transaction, CustomerProfile, FraudAlert)")
print(" 2. SchemaAdapter bridges existing Java schema <-> unified Python models")
print(" 3. Bidirectional flow: Java writes -> Python reads/enriches -> Java consumes")
print(" 4. PostgreSQL as single source of truth")
print(" 5. NO HTTP calls, NO duplication - true database-level integration")
print("="*70)
